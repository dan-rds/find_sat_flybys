from spacetrack import SpaceTrackClient
import datetime as dt 
st = SpaceTrackClient('ddrichar@ucsc.edu', 'n3JYvGMWBb3Yv3e')


import spacetrack.operators as op
drange = op.inclusive_range(dt.datetime(2016, 6, 26),
							dt.datetime(2016, 6, 27))

# Streaming downloads line by line
lines = st.tle(iter_lines=True, epoch=drange, orderby='TLE_LINE1', format='3le')
with open('tle.txt', 'w') as fp:
	for line in lines:
		fp.write(line)
		fp.write("\n")


# Parameter checking, using Space-Track's modeldef API
#xst.tle_latest(norad_cat_id=25544)
#TypeError: 'tle_latest' got an unexpected argument 'onrad_cat_id'

# # Automatic rate limiting
# for satno in my_satnos:
# 	# Gets limited to <20 requests per minute automatically by blocking
# 	st.tle()


curl --limit-rate 1M --cookie cookies.txt https://www.space-track.org/basicspacedata/query/class/boxscore > boxscore.json
def read_config_file(config_filename) -> (ephem.Observer, dict):
# 	d = {}
# 	with open(config_filename, "r+") as config:
# 		d = dict(yaml.safe_load(config))
# 	# converting xyz -> lla
# 	ecef = pyproj.Proj(proj='geocent', ellps='WGS84', datum='WGS84')
# 	lla = pyproj.Proj(proj='latlong', ellps='WGS84', datum='WGS84')
# 	lon, lat, alt = pyproj.transform(ecef, lla, d['x'], d['y'], d['z'], radians=True) # Yes it returs lon, lat not la, lon
# 	ret_obs = ephem.Observer()
# 	ret_obs.lat = lat
# 	ret_obs.lon = lon
# 	ret_obs.elevation = alt

# 	d[lon] = lon
# 	d[lat] = lat
# 	d[alt] = alt
# 	return ret_obs, d


About to redo thisblock from run
	tles_dict = read_tle_file()
	# tles_to_search = []
	# never_up_count = 0
	# means = []
	# i = 0
	for name, tle in tles_dict.items():
		sat = ephem.readtle(name, tle[0], tle[1])
		sat.compute(observatory)
		# i  += 1
		# if not i%100:
		# 	print(i)
		

		try: # Don't add satellites that are never up 
			start_val = observatory.next_pass(sat)
			#print(datetime.datetime.(start_val[0]))
			min_dist  = calc_min_dist_to_beam_in_window(start_time_utc, end, sat, observatory, target)
			means.append(min_dist)
			# tles_to_search.append(sat)
		except ValueError:
			never_up_count += 1
			
	print(never_up_count, " of the ", len(tles), " satellites never come into view")
	means.sort(key = lambda x: x[0])
	print(means)


earlier bloc from poscalc
def calc_ms_to_transit_beam(observatory, obs_settings, sat_tle):

    # peek(sat_tle)
    t = datetime.datetime.utcnow()
    observatory.date = ephem.Date(t)
    sat_tle.compute(observatory)

    ra1 = sat_tle.ra
    dec1 = sat_tle.dec
    range1 = sat_tle.range

    t = t + datetime.timedelta(0, 1)  # adding one ms
    observatory.date = ephem.Date(t)
    sat_tle.compute(observatory)

    ra2 = sat_tle.ra
    dec2 = sat_tle.dec
    range2 = sat_tle.range

    ra_delta = ra1 - ra2
    dec_delta = dec1 - dec2

    angular_speed_radians = math.sqrt(ra_delta**2 + dec_delta**2)

    degrees_per_ms = angular_speed_radians * 180 / math.pi
    arcmin_per_ms = degrees * 60
    return arcmin_per_ms


def calc_min_dist_to_beam_in_window(start_date, end_date, sat, observatory, target) -> (float, datetime.datetime):
    obs = copy.copy(observatory)
    t = start_date
    dt = datetime.timedelta(seconds=1)
    min_dist = (float("inf"), None)

    while t < end_date:
        observatory.date = t
        sat.compute(observatory)

        sat_ra = sat.ra
        sat_dec = sat.dec

        target_ra = target['ra']
        target_dec = target['dec']

        ra_diff = sat_ra - target_ra
        dec_diff = sat_dec - target_dec
        #print(ra_diff, dec_diff, type(ra_diff))
        angular_dist = math.sqrt(ra_diff**2 + dec_diff**2)

        min_dist = (
            angular_dist,
            t) if angular_dist < min_dist[0] else min_dist

        t = t + dt
    return min_dist

  #     interested_keys = ['_dec','_epoch','_pa','_pmdec','_pmra','_ra','_ratio','_spect','a_dec','a_epoch','a_ra','alt','az',
  # 'dec','elong','g_dec','g_ra','mag','name','neverup','parallactic_angle',
  # 'ra','radius','rise_az','rise_time','set_az','set_time','size','transit_alt','transit_time',]